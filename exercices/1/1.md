On se retrouve pour des exercices d'algorithmie cette fois.

Qui dit algorithmie... dit :

- Tableau
- Boucle
- Donn√©es
- Tests et validation

C'est pour √ßa que la structure de notre projet a un peu chang√©.

Comme d'habitude, tous les concepts ci-dessus te sont peut-√™tre _inconnus_, mais on va appliquer la m√™me m√©thode :

_Tu vas gal√©rer, mais √ßa vaut le coup !_

Tu seras toujours aid√© par les √©mojis donc pas de soucis √† te faire !

## Prends note

Je pense que suivant ton niveau, cet exercice peut √™tre **tr√®s compliqu√©** et j'en ai bien conscience.

Quelques r√®gles pour toi :

1. Passe maximum 20 minutes sur une partie, si tu n'as pas r√©ussi √† trouver la solution, regarde la vid√©o solution. **Ce n'est pas grave d'√©chouer, c'est m√™me normal** ! Apr√®s le cours, tu retourneras sur ces exercices et tu les feras les yeux ferm√©s.
2. Quand tu regardes les vid√©os solutions, fais tout √† nouveau avec moi pour bien comprendre.

## Exercice 1

On va faire un exercice... d'algorithmie !

Je te mets en situation. Les lutins du p√®re No√´l ne doivent pas trop manger de calories, donc ils les √©crivent toutes comme ceci :

```
1000
2000
3000

4000

5000
6000
```

Cette liste repr√©sente les calories r√©colt√©es par 3 lutins. Chaque espace d√©limite un lutin. Puis chaque ligne repr√©sente un repas avec des calories.

Donc le premier lutin prend 1000 + 2000 + 3000 = 6000 calories.

Le deuxi√®me lutin prend 4000 calories.

Le troisi√®me lutin prend 5000 + 6000 = 11000 calories.

Ta t√¢che est de trouver le lutin qui a mang√© le plus de calories et me dire combien de calories il a mang√©.

#### Explications

Dans notre exercice, on retrouvera des fichiers `data-test.txt` qui contiennent des donn√©es de **test** afin de tester tes fonctions.

On retrouvera aussi des fichiers `data.txt` qui contiennent des donn√©es **r√©elles** qui permettront de v√©rifier que ton programme fonctionne avec n'importe quelles donn√©es.

Dans le fichier exercice, `1.js`, tu retrouveras deux fonctions export√©es : `part1` et `part2` que l'on verra dans la suite.

Aussi, tu verras ce code que j'ai d√©j√† fait :

```js
const fs = require('fs');
const path = require('path');

function readFileContent(p) {
  const filePath = path.join(__dirname, p);
  const fileContent = fs.readFileSync(filePath).toString();
  return fileContent;
}
```

Celui-ci permet de lire le fichier `data.txt` et de le transformer en une cha√Æne de caract√®res.

Tu vois qu'il prend en param√®tre `p` qui repr√©sente le chemin vers le fichier, ici `./data-test.txt` pour tes tests.

#### Partie 1

Pour calculer le total de calories d'un lutin, tu devras cr√©er une fonction `findLargestSum` qui va venir prendre notre cha√Æne de caract√®res et la couper plusieurs fois.

Tu vois que dans notre fichier, chaque lutin est s√©par√© par deux retours √† la ligne (`\n\n`).

- [split](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split)

Pour "couper" notre cha√Æne de caract√®res, nous allons utiliser la fonction `split` qui va d√©couper notre cha√Æne de caract√®res en plusieurs morceaux.

```js
const str = 'Hello\nWorld';
const splitted = str.split('\n');
console.log(splitted); // ['Hello', 'World']
```

Tu vois que la variable `splitted` repr√©sente maintenant un **tableau** que nous verrons en d√©tail par la suite. Mais un tableau, c'est comme une liste, on peut y acc√©der avec des index.

```js
splitted[0]; // 'Hello'
splitted[1]; // 'World'
```

Nous allons utiliser cette liste pour la parcourir et calculer le total de calories de chaque lutin.

Pour cela, tu vas devoir utiliser une boucle `for` qui va parcourir notre tableau.

```js
for (let i = 0; i < splitted.length; i++) {
  // const lutin = splitted[i];
}
```

Et ensuite, le lutin, tu vas devoir **encore une fois** le s√©parer pour avoir les calories de chaque repas.

```js
const lutin = splitted[i];
const calories = lutin.split('\n');
```

Puis tu pourras utiliser le nouveau tableau `calories` pour calculer le total de calories avec une autre boucle `for` et une variable `sum` qui va stocker le total de calories.

```js
let sum = 0;
for (let j = 0; j < calories.length; j++) {
  // r√©cup√©rer la valeur de calories[j] et l'ajouter √† sum
  // N'oublie pas de convertir la cha√Æne de caract√®res en nombre en utilisant `Number`
}
```

Et voil√† ! Tu as le `sum` de nos lutins maintenant. Il te suffit de trouver le plus grand et de le retourner pour avoir la bonne r√©ponse.

Tu trouveras de l'aide dans le fichier `1.js` pour t'aider √† trouver la bonne r√©ponse.

### Commandes

#### Tester ton code

```bash
node exercices/1/1.js
```

Cela va ex√©cuter ton code et tu pourras voir les `console.log` avec la r√©ponse.

N'h√©site pas √† ajouter des logs pour voir ce qui se passe dans ton code.

#### Valider ton code

```bash
npm run test 1.1
```

## Partie 2 : Les 3 plus grands

Finalement, nous souhaitons conna√Ætre les 3 lutins qui ont mang√© le plus de calories. Il ne faut plus seulement trouver le premier, mais les 3 premiers.

Tu vas devoir cr√©er une fonction `findSumOfThreeLargest` qui va faire la m√™me chose qu'avant, sauf que maintenant tu vas stocker chaque taille de lutin dans un tableau `sums`.

```js
const sums = [];

for (let i = 0; i < splitted.length; i++) {
  // ...
  sums.push(sum);
}
```

Cela te permettra d'avoir un tableau qui contient **tous** les totaux de calories de chaque lutin.

Ensuite, tu vas devoir trouver les 3 plus grands nombres de ce tableau.

Pour cela, nous allons trier le tableau avec la fonction `sort` qui va trier le tableau dans l'ordre croissant.

```js
const sorted = sums.sort((a, b) => a - b);
```

Ici, la fonction `sort` prend en param√®tre un callback qui va comparer deux nombres `a` et `b` et retourner un nombre n√©gatif si `a` est plus petit que `b`, un nombre positif si `a` est plus grand que `b`, et `0` si `a` est √©gal √† `b`.

Gr√¢ce √† cela, l'algorithme va pouvoir trier le tableau dans l'ordre croissant.

On refait cette fonction `sort` dans les exercices du cours üòâ

Une fois que tu as tri√© le tableau, tu peux r√©cup√©rer les 3 derniers √©l√©ments en utilisant des index n√©gatifs.

```js
const sorted = [1, 2, 3, 4, 5];
const lastIndex = sorted.length - 1; // => 5 (length) - 1 = 4
const last = sorted[lastIndex]; // 5
```

Tu peux faire la m√™me chose avec `-1`, `-2` et `-3` pour r√©cup√©rer les 3 derniers √©l√©ments du tableau.

Il te suffit ensuite de les additionner pour trouver le bon r√©sultat !

### Commandes

#### Tester ton code

```bash
node exercices/1/1.js
```

Cela va ex√©cuter ton code et tu pourras voir les `console.log` avec la r√©ponse.

N'h√©site pas √† ajouter des logs pour voir ce qui se passe dans ton code.

#### Valider ton code

```bash
npm run test 1.2
```

## Partie 3 : Refactor using array methods

Maintenant que tu as r√©ussi √† trouver les 3 plus grands nombres, tu vas devoir refactoriser ton code pour utiliser des m√©thodes de tableau.

Pour nos deux fonctions, il est possible d'utiliser les m√©thodes de tableaux pour nous simplifier la vie et √©viter d'√©crire des boucles `for`.

_Rappel : c'est normal que tu ne saches pas les faire, le but est de te pr√©parer √† les apprendre dans le cours._

Pour la fonction `findLargestSum` on va pouvoir utiliser **reduce** qui est une des fonctions les plus compliqu√©es.

`reduce` comme son nom l'indique permet de **r√©duire** un tableau √† une seule valeur !

Et c'est exactement ce qu'on veut, dans la fonction on prend notre tableau qu'on split avec `\n\n` et on cherche √† le r√©duire √† un seul nombre qui est le **plus gros total de calories** pour nos elfes.

Voici comment on utilise reduce :

```js
const numbers = [10, 11, 144, 4];

// number est la valeur de l'√©l√©ment du tableau
const bigger = numbers.reduce((acc, number) => {
  if (number > acc) {
    // La valeur retourn√©e remplace la valeur de acc
    return number;
  }

  return acc;
}, 0); // 0 est la valeur initiale de acc qui est le premier param√®tre de la fonction
```

Avec ce code, on vient r√©duire notre tableau au **plus grand nombre**.

On pourra aussi faire la `sum` :

```js
const numbers = [10, 11, 144, 4];

const sum = numbers.reduce((acc, number) => {
  return acc + number;
}, 0);
```

Ici, chaque fois on retourne l'acc (qui est la premi√®re fois 0) + le nombre.

Ce qui donne pour chaque it√©ration ceci :

```txt
1: 0 + 10 = 10
2: 10 + 11 = 21
3: 21 + 144 = 165
4: 165 + 4 = 169
```

Tu vois que chaque fois on reprend la valeur de acc et on lui ajoute le nombre.

**Ta t√¢che est de** remplacer la boucle `for` par une fonction `reduce` pour trouver le plus grand nombre.

(les tests sont les m√™mes que pour la partie 2)

**Bonus** : utiliser `reduce` une _deuxi√®me_ fois √† l'int√©rieur de l'autre `reduce` pour faire la somme.

## Partie 4 : Refactor using array methods

Dans la deuxi√®me fonction, on transforme un tableau (celui d√©fini gr√¢ce √† .split de `\n\n`) en un autre tableau qui contient les totaux de calories pour chaque elfe.

Ce qui est important √† noter, c'est que le nombre d'√©l√©ments dans le tableau initial et dans le tableau des sommes de calories est le m√™me.

Dans ce cas, ce que l'on veut faire, c'est _cr√©er un nouveau tableau_ en partant d'un tableau initial ! Pour √ßa, on peut utiliser la m√©thode `.map` !

`.map` permet de cr√©er un nouveau tableau en partant d'un tableau initial.

```js
const numbers = [10, 11, 144, 4];

const newNumbers = numbers.map((number) => {
  return number * 2;
});

// newNumbers = [20, 22, 288, 8]
```

Tu vois ici, j'ai cr√©√© un nouveau tableau en partant du tableau `numbers` et en multipliant chaque nombre par 2.

Ce que tu veux faire, c'est prendre le param√®tre, le diviser par `\n` et faire la somme de chaque √©l√©ment pour le retourner.

C'est un cas **parfait** pour map, donc au boulot !

**Bonus** : utilise `reduce` une _deuxi√®me_ fois √† l'int√©rieur de l'autre `reduce` pour faire la somme.

## Conclusion

Bravo ! Tu es all√© jusqu'au bout.

Que tu aies r√©ussi ou non du premier coup, tu peux √™tre fier de toi et tu pourras revenir sur cet exercice apr√®s le cours.
